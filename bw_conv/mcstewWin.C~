#include "TROOT.h"
#include "TMath.h"
#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooGaussian.h"
#include "RooTruthModel.h"
#include "RooExponential.h"
#include "RooResolutionModel.h"
#include "RooGaussModel.h"
#include "RooCBShape.h"
#include "RooAddModel.h"
#include "RooAbsPdf.h"
#include "RooAddPdf.h"
#include "RooHistPdf.h"
#include "RooProdPdf.h"
#include "RooVoigtian.h"
#include "RooDecay.h"
#include "RooStats/ModelConfig.h"
#include "TCanvas.h"
#include "TTree.h"
#include "RooWorkspace.h"
#include "TCut.h"
#include "RooWindowPdf.h"
#include "TCanvas.h"
#include "RooChebychev.h"
#include "RooDstD0BG.h"
#include "TFile.h"
#include "RooPlot.h"
#include "RooHist.h"
#include "TAxis.h"
#include "RooDataHist.h"
#include "ksfun.h"
#include "TSystem.h"
#include "RooFitResult.h"
#include "TLatex.h"
#include <string>
#include <fstream>
#include <sstream>
#include <utility>
#include "fitModels.C"
#include "TH1F.h"
#include "RooBackPdf.h"
#include "RooDataHist.h"
#include "TH1F.h"
#include "TLine.h"
#include "TGraphErrors.h"
#include "RooFFTConvPdf.h"
#include "RooStats/ProfileLikelihoodCalculator.h"
#include "RooStats/LikelihoodInterval.h"
#include "RooStats/LikelihoodIntervalPlot.h"
#include "RooStudentT.h"

using namespace RooFit;
using namespace RooStats;

// Define type to store value and error
typedef struct {
  double value;
  double error;
} ValueWithError;

// Define type to store results
typedef struct {
  ValueWithError n1;
  ValueWithError mean;
  ValueWithError scale; 
  ValueWithError width; 
} Result;

// Define function to turn RooRealVar to ValueWithError
void fillValueWithError(ValueWithError* val,RooRealVar* var){
  val->value = var->getVal();
  val->error = var->getError();
}

// Define function to print onto a canvas
void addBlurb(TCanvas* can, std::string blurb){
  std::cout << "Adding Blurb " << can->GetName() << std::endl;
  TLatex *myLatex = new TLatex(0.5,0.5,"");
  myLatex->SetTextFont(132); 
  myLatex->SetTextColor(1); 
  myLatex->SetTextSize(0.055); 
  myLatex->SetNDC(kTRUE); 
  myLatex->SetTextAlign(11);  
  myLatex->SetTextSize(0.07); 
  myLatex->DrawLatex(0.66, 0.75,blurb.c_str()); 
}

// Main function
Result* mcfitbwcon2(std::string fittype = "2CB", std::string resname = "psi2S", std::string modelname = "bwc", std::string convString = "FFT",
                    std::string filename = "../data/mcpsi_Qcut_vetos.root", std::string mbranch = "mjpipi", std::string inputcut = "",
                    double minmass = 3665., double maxmass = 3705.,
                    double sval1 = 2.93e-3, bool fixS1 = false, double sval2 = 1.96e-3, bool fixS2 = true,
                    double n1val = 2.5    , bool fixN1 = true , double n2val = 1.     , bool fixN2 = true,
                    double fval  = 0.7    , bool fixf  = true ,  
                    double scaleVal = 1, bool fixScale = false, 
                    bool fixWidth = false,
                    std::string epsfile = "can.eps", bool makeplot = true, int nbins = 10000, double buff = 0.5){

  Result* res = new Result();

  // Load file 
  TFile* theFile = new TFile(filename.c_str()); 
  std::cout << "File: " << filename << std::endl;
  // Load tree from file
  TTree* tree = (TTree*)theFile->Get("DecayTree");

  // Prepare variable for fitting to
  RooRealVar m(mbranch.c_str(), mbranch.c_str(), minmass, maxmass);
 
  // Apply user specified cut to the data
  std::stringstream cutstream; 
  std::cout << inputcut << std::endl;
  cutstream  << mbranch << " > " << minmass << " &&" 
                << mbranch  << "< "   << maxmass ;
  std::cout << "Cut " << cutstream.str() << std::endl; 
  TCut thecut = cutstream.str().c_str();
 
  // Initialise histogram for visualising data
  TH1F* histo = new TH1F("histo","histo", 1000, minmass, maxmass);
  std::string streamToHisto = mbranch + " >> histo";
  // tree->Draw(streamToHisto.c_str(), thecut);

  // Initialise and fill dataset
  RooDataSet data("data","data", RooArgSet(m), Import(*tree), Cut(thecut)) ;  
 
  // Initialise variables for X(3872) or psi(2S)
  double mval ; double wval; double avalue; std::string par1, par2,par3;
  double bhi, blow;
  if (resname=="X"){
    wval = 0.317;
    mval = 3871.5;
    avalue = 717.; 
    bhi = 3877.;
    blow = 3869.3;
    par1= "2.48";
    par2= "8.1";
    par3= "0.474*1000";    
  }
  else {
    wval = 0.304;
    mval = 3686.11;
    avalue = 518.;
    blow = 3685.25;
    bhi = 3690.65;
    par1 = "2.48";
    par2 = "10.5";
    par3 ="0.595*1000";
  }

  // *** Initialise RooFit Variables ***
  // Min and Max RooWindowPDF
  RooRealVar hi("hi", "hi", bhi);  
  RooRealVar low("low", "low",  blow);
  // Mass and Width to fit  
  RooRealVar* mx    = new RooRealVar("mx"   , "mx"   , mval, mval-2., mval+2.);
  RooRealVar* width = new RooRealVar("width", "width", wval,    0.01, 10*0.304); 
  // ??
  RooRealVar scale("scale", "scale", scaleVal, 0.5, 1.7); scale.setConstant(fixScale);
  // Sigmas for CB and Gauss shapes
  RooFormulaVar s ("sigma" , "sigma" , scaledSigma(sval1).c_str(), scale); 
  RooFormulaVar s2("sigma2", "sigma2", scaledSigma(sval2).c_str(), scale); 
  // BreitWigner models - is this syntax correct?
  RooRelBreitWigner* bWigner1 = bwg2(m, minmass, maxmass, mx, width, "bw1", avalue, fixWidth);
  RooRelBreitWigner* bWigner2 = bwg2(m, minmass, maxmass, mx, width, "bw2", avalue, fixWidth);
  // ?? 
  RooWindowPdf* windowpdf = new RooWindowPdf("window","window", *mx,hi,low);
  // Windowed Breit-Wigner
  RooProdPdf wbWigner1 = RooProdPdf("wb1", "wb1", RooArgList(*bWigner1, *windowpdf) );
  RooProdPdf wbWigner2 = RooProdPdf("wb2", "wb2", RooArgList(*bWigner2, *windowpdf) );
  // Fraction for combining convolved PDFs
  RooRealVar f("f","f",fval, 0.0,1.0); f.setConstant(fixf);
  // ns for CB
  RooRealVar* n2 = new RooRealVar("n2","n2",n2val, 0.5, 200); n2->setConstant(fixN2);
  RooRealVar* n1 = new RooRealVar("n1","n1",n1val, 0.5, 500); n1->setConstant(fixN1);
  // ??
  double delta = 0.5*TMath::Abs(0.9*(sval1 - sval2));
  //RooRealVar s2("s2","s2",sval2, sval1 +delta, 10e-3); s2.setConstant(fixS2);
  //RooRealVar s("s1","s1",sval1, 0, sval1 +2*delta); s.setConstant(fixS1);
  // Mean value of m
  RooRealVar meanres("meanres","meanres", 0);
  // ??
  //RooFormulaVar* ac = tailModel(s,"atail1",par1, par2, par3);
  //RooFormulaVar* ac2 = tailModel(s2,"atail2",par1, par2, par3);
  // ??
  std::stringstream tval1; tval1 << sval1;
  std::stringstream tval2; tval2 << sval2; 
  // alphas for CB
  RooFormulaVar* ac  = tailModelScale(scale, tval1.str(), "atail1", par1, par2, par3);
  RooFormulaVar* ac2 = tailModelScale(scale, tval2.str(), "atail2", par1, par2, par3);
  // Initialise models for fitting
  RooCBShape cb1("crystalball1", "cb(x,mean,sigma)", m, meanres, s , *ac,*n1);
  RooCBShape cb2("crystalball2", "cb(x,mean,sigma)", m, meanres, s2, *ac,*n2); // should this be ac2?
  RooGaussian gauss2("gauss2", "gauss", m, meanres, s2);
  RooStudentT student("student", "student", m, meanres ,s2, *n2);

  // Convolve functions
  RooAbsPdf* fun1 = 0; RooAbsPdf* fun2 = 0; RooAbsPdf* fun3 = 0; 
  if (convString == "FFT"){
    // Fast fourier transform
    m.setBins(nbins,"cache");  // what is cache?
    // Convolve breit-wigner with models
    RooFFTConvPdf* tfun1 = new RooFFTConvPdf("convPdf1","convPdf1",  m, wbWigner1,cb1);
    RooFFTConvPdf* tfun2 = new RooFFTConvPdf("convPdf2","convPdf2",  m, wbWigner2,cb2); 
    RooFFTConvPdf* tfun3 = new RooFFTConvPdf("convPdf3","convPdf3",  m, wbWigner2,gauss2); 
    // Set the range in which the convolution is performed
    tfun1->setBufferStrategy(RooFFTConvPdf::Extend);
    tfun1->setBufferFraction(buff); 
    tfun2->setBufferStrategy(RooFFTConvPdf::Extend);
    tfun2->setBufferFraction(buff);
    tfun3->setBufferStrategy(RooFFTConvPdf::Extend);
    tfun3->setBufferFraction(buff);
    // Store functions
    fun1 = tfun1; fun2 = tfun2; fun3 = tfun3;
 }
 else {
    // Numerically convolve
    RooNumConvPdf* tfun1 = new RooNumConvPdf("convPdf1", "convPdf1", m, *bWigner1, cb1); 
    RooNumConvPdf* tfun2 = new RooNumConvPdf("convPdf2", "convPdf2", m, *bWigner2, cb2);
    RooNumConvPdf* tfun3 = new RooNumConvPdf("convPdf3", "convPdf3", m, *bWigner2, gauss2);
    // Set the range in which the convolution is performed
    tfun1->setConvolutionWindow(meanres, s, 50); 
    tfun2->setConvolutionWindow(meanres, s, 50);
    tfun3->setConvolutionWindow(meanres, s, 50);
    // Store functions
    fun1 = tfun1; fun2 = tfun2;fun3 = tfun3;
 }

  // Combine the pdfs
  RooAddPdf* sigmodel;
  if (fittype =="2CB") {
    sigmodel = new RooAddPdf("sigmodel", "sigmodel", RooArgList(*fun1, *fun2), f);
  }
  else {
    sigmodel = new RooAddPdf("sigmodel", "sigmodel", RooArgList(*fun1, *fun3), f);
  }

  // RooDataHist dataHisto("data", "dataset", m , histo); 
  // Fit model to data
  RooFitResult* fresult = sigmodel->fitTo(data, Save(), RooFit::Optimize(kFALSE)); 
  std::cout << "Fit complete." << std::endl;
  
  // Make a pretty plot
  if (makeplot){
    // Prepare canvas
    RooPlot* mframe = m.frame();
    TCanvas* can1 = new TCanvas("can1", "can1",10,44,600,400);
    TPad* pad1 = new TPad("pad1","This is pad1",0.05,0.25,0.95,0.97);
    TPad* pad2 = new TPad("pad2","This is pad2",0.05,0.0,0.95,0.25);
    //  RooDataHist dataHisto("data", "dataset", m , histo); 
    // RooFitResult* fresult = sigmodel->fitTo(dataHisto,Save(),RooFit::Optimize(kFALSE)); 
    pad1->Draw();
    pad2->Draw();
    pad1->cd();
    // Plot data and model
    data.plotOn(mframe, Binning(50));
    sigmodel->plotOn(mframe, LineColor(2)); 
    sigmodel->plotOn(mframe, Components("convPdf1") , LineColor(4), LineStyle(2));
    if (fittype =="2CB") {
      sigmodel->plotOn(mframe, Components("convPdf2") , LineColor(3), LineStyle(3));
    }
    else {
      sigmodel->plotOn(mframe, Components("convPdf3") , LineColor(3), LineStyle(3));
    }
    sigmodel->plotOn(mframe, LineColor(2)); 
    // Format plot
    mframe->SetTitle("");
    TAxis* xachse = mframe->GetXaxis(); TAxis* yachse = mframe->GetYaxis();
    xachse->SetTitleFont (132);
    yachse->SetTitleFont (132);
    xachse->SetLabelFont (132);
    yachse->SetLabelFont (132); 
    xachse->SetTitle("m(J/#psi #pi^{+} #pi^{-}) [GeV/c^{2}]"); 
    std::string aystring = massCandidates(minmass,maxmass,50); 
    yachse->SetTitle(aystring.c_str()); 
    yachse->SetTitleOffset(1.05); 
    xachse->SetTitleOffset(0.95);
    xachse->SetTitleSize(0.05); 
    yachse->SetTitleSize(0.05);
    // Draw
    mframe->Draw();

    // Plot pulls
    pad2->cd();
    RooPlot* frame2 =  m.frame();
    RooHist* phist = mframe->pullHist( );
    frame2->addPlotable(phist,"P");
    frame2->SetMinimum(-6.5); 
    frame2->SetMaximum(6.5);
    // Make pretty
    xachse = frame2->GetXaxis(); yachse = frame2->GetYaxis();
    xachse->SetTitleFont (132);
    yachse->SetTitleFont (132);
    xachse->SetLabelFont (132);
    yachse->SetLabelFont (132); 
    yachse->SetTitleOffset(0.15); 
    yachse->SetTitleSize(0.2);
    yachse->SetLabelSize(0.08);
    xachse->SetLabelOffset(0.2);
    yachse->SetNdivisions(110);
    frame2->SetXTitle("");
    frame2->SetYTitle("pull");
    frame2->SetTitle("");
    frame2->Draw() ; 
    TLine* line = new TLine(minmass,0, maxmass, 0);
    // Draw
    line->Draw();
    can1->Print(epsfile.c_str());
 }
  // output
  // const RooArgList& fitPars = fresult->floatParsFinal(); 
  // RooRealVar* fitmean = (RooRealVar*)fitPars.at(0);
  // RooRealVar* fitscale = (RooRealVar*)fitPars.at(1);
  fillValueWithError(&res->mean,mx);
  fillValueWithError(&res->scale,&scale);
  fillValueWithError(&res->width,width);
  fillValueWithError(&res->n1,n1);

  // ??
  // generate some pdf

  /* filebuf fb;
  fb.open ("mcpsifits.txt",ios::out);
  ostream os(&fb); 
  for (int i = 0; i < 1000; ++i){
    const RooArgList& sample  = result->randomizePars();
    RooRealVar* c1 = (RooRealVar*)sample.at(1);
    os << c1 << c2 << c3 << std::endl;
  }
 
  fb.close();
  */

  // theFile->Close();

  //std::cout  << 1000*res->mean.value << " " << 1000*res->mean.error  << " s1 " << 1000*s.getVal() << " "
  //           <<  " "  << 1000*s.getError() << " " <<   1000*s2.getVal() <<  " " << 1000*s2.getError() <<  std::endl;
 
  // Output value
  return res;
}
